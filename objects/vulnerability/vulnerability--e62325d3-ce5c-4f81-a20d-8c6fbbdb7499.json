{
    "type": "bundle",
    "id": "bundle--3199cc95-4a01-4939-8b27-5d397ec600f7",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--e62325d3-ce5c-4f81-a20d-8c6fbbdb7499",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2025-04-17T00:22:47.605693Z",
            "modified": "2025-04-17T00:22:47.605693Z",
            "name": "CVE-2025-22077",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmb: client: Fix netns refcount imbalance causing leaks and use-after-free\n\nCommit ef7134c7fc48 (\"smb: client: Fix use-after-free of network\nnamespace.\") attempted to fix a netns use-after-free issue by manually\nadjusting reference counts via sk->sk_net_refcnt and sock_inuse_add().\n\nHowever, a later commit e9f2517a3e18 (\"smb: client: fix TCP timers deadlock\nafter rmmod\") pointed out that the approach of manually setting\nsk->sk_net_refcnt in the first commit was technically incorrect, as\nsk->sk_net_refcnt should only be set for user sockets. It led to issues\nlike TCP timers not being cleared properly on close. The second commit\nmoved to a model of just holding an extra netns reference for\nserver->ssocket using get_net(), and dropping it when the server is torn\ndown.\n\nBut there remain some gaps in the get_net()/put_net() balancing added by\nthese commits. The incomplete reference handling in these fixes results\nin two issues:\n\n1. Netns refcount leaks[1]\n\nThe problem process is as follows:\n\n```\nmount.cifs                        cifsd\n\ncifs_do_mount\n  cifs_mount\n    cifs_mount_get_session\n      cifs_get_tcp_session\n        get_net()  /* First get net. */\n        ip_connect\n          generic_ip_connect /* Try port 445 */\n            get_net()\n            ->connect() /* Failed */\n            put_net()\n          generic_ip_connect /* Try port 139 */\n            get_net() /* Missing matching put_net() for this get_net().*/\n      cifs_get_smb_ses\n        cifs_negotiate_protocol\n          smb2_negotiate\n            SMB2_negotiate\n              cifs_send_recv\n                wait_for_response\n                                 cifs_demultiplex_thread\n                                   cifs_read_from_socket\n                                     cifs_readv_from_socket\n                                       cifs_reconnect\n                                         cifs_abort_connection\n                                           sock_release();\n                                           server->ssocket = NULL;\n                                           /* Missing put_net() here. */\n                                           generic_ip_connect\n                                             get_net()\n                                             ->connect() /* Failed */\n                                             put_net()\n                                             sock_release();\n                                             server->ssocket = NULL;\n          free_rsp_buf\n    ...\n                                   clean_demultiplex_info\n                                     /* It's only called once here. */\n                                     put_net()\n```\n\nWhen cifs_reconnect() is triggered, the server->ssocket is released\nwithout a corresponding put_net() for the reference acquired in\ngeneric_ip_connect() before. it ends up calling generic_ip_connect()\nagain to retry get_net(). After that, server->ssocket is set to NULL\nin the error path of generic_ip_connect(), and the net count cannot be\nreleased in the final clean_demultiplex_info() function.\n\n2. Potential use-after-free\n\nThe current refcounting scheme can lead to a potential use-after-free issue\nin the following scenario:\n\n```\n cifs_do_mount\n   cifs_mount\n     cifs_mount_get_session\n       cifs_get_tcp_session\n         get_net()  /* First get net */\n           ip_connect\n             generic_ip_connect\n               get_net()\n               bind_socket\n\t         kernel_bind /* failed */\n               put_net()\n         /* after out_err_crypto_release label */\n         put_net()\n         /* after out_err label */\n         put_net()\n```\n\nIn the exception handling process where binding the socket fails, the\nget_net() and put_net() calls are unbalanced, which may cause the\nserver->net reference count to drop to zero and be prematurely released.\n\nTo address both issues, this patch ties the netns reference counti\n---truncated---",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2025-22077"
                }
            ]
        }
    ]
}